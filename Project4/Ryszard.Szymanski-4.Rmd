---
title: "Project 4"
author: "Ryszard Szymański"
date: "4/4/2020"
output: html_document
---

```{r setup, include=FALSE}
library(igraph)
library(ggplot2)
library(purrr)
knitr::opts_chunk$set(echo = TRUE)
```

## Zadanie 1
Do wykonania zadań wykorzystano sieć emaili firmy Enron (źródło: http://networkrepository.com/email-EU.php).
```{r}
enron <- drake::readd(enron_graph)
hist_vals <- hist(degree(enron), plot = FALSE)

hist_df <- hist2df(hist_vals)

ggplot(hist_df, aes(x = breaks, y = counts)) + 
  geom_line()
```

## Zadanie 2
Rysunek jest bardziej czytelny -- bliżej mu do linii prostej, której się spodziewamy przy rozkładach potęgowych. Można jednak zauważyć szum bliżej końca narysowanej linii.
```{r warning=FALSE}
ggplot(hist_df, aes(x = breaks, y = counts)) + 
  geom_line() + 
  scale_x_log10() +
  scale_y_log10()
```

## Zadanie 3 i 4
Zastosowanie logarytmicznego binowania pozwoliło na wygładzenie szumu, które pojawiło się w zadaniu 2
```{r}
enron_degrees <- degree(enron)
breaks <- exp(seq(log(min(enron_degrees)), log(max(enron_degrees)), length.out = length(hist_vals$breaks)))
hist_vals_log_binned <- hist(enron_degrees, breaks = breaks, probability = TRUE)

hist_df <- hist2df(hist_vals_log_binned)

ggplot(hist_df, aes(x = breaks, y = counts)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10()
```


## Zadanie 5
```{r}
enron_cdf <- ecdf(enron_degrees) 
enron_cdf_summary <- summary(enron_cdf)
cdf_min <- enron_cdf_summary[["Min."]]
cdf_max <- enron_cdf_summary[["Max."]]

x <- seq(cdf_min, cdf_max)
survival_fun_values <- 1 - enron_cdf(x)
data.frame(
  x = x,
  y = survival_fun_values
) %>% ggplot(aes(x = x, y = y)) +
  geom_line()
```

## Zadanie 6
Najbardziej czytelny jest wykres w którym zastosowano jednocześnie skale logarytmiczne oraz logarytmiczne binowanie.

## Zadanie 7
```{r}
lm_fit <- lm(log(counts) ~ log(breaks), data = hist_df)
lm_fit
```
## Zadanie 8
```{r}
alpha <- 1 + length(hist_vals_log_binned$counts) * sum(log(hist_vals_log_binned$counts / min(hist_vals_log_binned$counts)))^(-1)
alpha
```
## Zadanie 9
```{r}
alpha_no_xmin <- 1 + length(hist_vals_log_binned$counts) * sum(log(hist_vals_log_binned$counts))^(-1)
alpha - alpha_no_xmin
```

## Zadanie 11
Zakładamy, że sieć jest nieskorelowana i chcemy pokazać, że
$$\langle k_{nn} \rangle (k_i) = \frac{\langle k^2 \rangle}{\langle k \rangle}$$
Wychodzimy od definicji średniego stopnia najbliższego węzłą (dla węzła o stopniu $k_i$) -- (użyto definicji z ksiażki Państwa Fronczaków):
$$\langle k_{nn} \rangle (k_i) = \sum\limits_{k_j}k_jP(k_j|k_i)$$
Korzystając wyznaczego wzoru na prawdopobieństwo warunkowe $P(k_i | k_j)$ otrzymujemy
$$\langle k_{nn} \rangle (k_i) = \sum\limits_{k_j}k_j \frac{P(k_j, k_i) \langle k\rangle}{k_i P(k_i)}$$
Następnie korzystając z założenia, że sieć jest nieskorelowana, to $P(k_i, k_j) = P_u(k_i, k_j)$ otrzymujemy (wzór na $P_u$ również pochodzi z książki Państwa Fronczaków):
$$\langle k_{nn} \rangle (k_i) = \sum\limits_{k_j}k_j \frac{k_jk_iP(k_i)P(k_j)}{\langle k \rangle^2} \frac{\langle k\rangle}{k_i P(k_i)} = \sum\limits_{k_j} \frac{k_j^2 P(k_j)}{\langle k \rangle} = \frac{1}{\langle k \rangle}\sum\limits_{k_j}k_j^2P(k_j)$$
$P(k_j)$ oznacza prawdopodobieństwo wystąpienia wierzchołka o stopniu $k_j$, stąd wyrażenie $\sum\limits_{k_j}k_j^2P(k_j)$ oznacza średnią arytmetyczną kwadratu stopni wierzchołków. Stąd, otrzymujemy:
$$\langle k_{nn} \rangle (k_i) = \frac{\langle k^2 \rangle}{\langle k \rangle}$$

## Zadanie 12
```{r}
drake::readd(enron_graph_characteristic_plot)
```

## Zadanie 13

### Ze zmianą rozkładu stopni wierzchołków
```{r echo=FALSE}
drake::readd(enron_altered_each_edge_characteristic_plot)
```

### Bez zmiany rozkładu stopni wierzchołków
```{r echo=FALSE}
drake::readd(enron_altered_degseq_kept_characteristic_plot)
```

## Zadanie 14
TODO

## Zadanie 15
```{r}
enron_altered_degseq_kept <- drake::readd(enron_altered_degseq_kept)
enron_altered_each_edge <- drake::readd(enron_altered_each_edge)

igraph::assortativity_degree(enron)
igraph::assortativity_degree(enron_altered_each_edge)
igraph::assortativity_degree(enron_altered_degseq_kept)
```

## Zadanie 17
Średnia odległość mierzy "małość świata", podczas gdy Wydajność mierzy efektywnosć przepływu informacji między węzłami. Żadna z tych miar nie jest lepsza, obie opisują trochę inne wielkości i ich przydatność zależy od sytuacji:

* W sieciach, gdzie występują wierzchołki izolowane Średnia odległość zawsze będzie miała wartości nieskończone. W tego typu przypadkach lepiej skorzystać z Wydajności

* Średnia odległość może się przydać w następującym przypadku: Sieć Transportu miejskiego, gdzie wagi krawędzi oznaczają czas przejazdu od jednego węzła do drugiego. Średnia odległość informuje nas o konkretnej rzeczywistej wartości -- co może nas interesować jeżeli naszym celem jest minimalizacja średniego czasu dojazdu do centrum miasta. 

## Zadanie 18
TODO

## Zadanie 19
TODO

## Zadanie 20

### Zwycięzcy nagrody nobla
```{r}
drake::readd(nobel_prize_winners_erdos_number_histogram)
```

### Zwycięzcy medalu fieldsa
```{r}
drake::readd(field_medal_winners_erdos_number_histogram)
```

## Zadanie 21
```{r}
knitr::kable(drake::readd(actors_bacon_number_data))
```

## Projekt
Wszystkie zaimplementowane miary zostały porównane z ich odpowiednikami z biblioteki `igraph` na następującym grafie:
```{r}
test_graph <- drake::readd(example_graph_project4)
plot(test_graph)
```

### Średni stopień najbliższego węzła
```{r}
mean_nearest_vertex_degree(test_graph)
```

### Wykładnik w sieciach potęgowych
```{r}
sample_vertex_degrees <- poweRlaw::rpldis(1e6, xmin = 100, alpha = -2.5)
network_exponent(sample_vertex_degrees, xmin = 100)
```

### Współczynnik korelacji
```{r}
network_correlation(test_graph)
```

```{r}
igraph::assortativity_degree(test_graph)
```


### Współczynniki Gronowania

#### Wersja 1
```{r}
clustering_coefficient_1(test_graph)
```

#### Wersja 2
```{r}
clustering_coefficient_2(test_graph)
```


```{r}
igraph::transitivity(test_graph)
```

### Średnia odległość
```{r}
mean_distance(test_graph)
```

```{r}
igraph::mean_distance(test_graph)
```

### Wydajność
```{r}
efficiency(test_graph)
```

```{r}
brainGraph::efficiency(test_graph, "global")
```

### Pośrednictwo węzłowe

```{r}
node_betweenness(test_graph)
```

**Uwaga:** Implementacja tej miary w igraphie nie zawiera czynnika: $\frac{2}{(N - 1)(N - 2)}$.
Źródło: https://igraph.org/r/doc/betweenness.html
```{r}
vertex_count <- vcount(test_graph)
2 * igraph::betweenness(test_graph) / ((vertex_count - 1) * (vertex_count - 2))
```

